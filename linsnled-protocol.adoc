= The LinsnLED ethernet protocol: An attempt at reverse engineering
Sophie Tyalie <dev@flowerpot.me>
:reproducible:
:description: The document's description.
:title-page:
:doctype: book
:sectnums:
:revnumber: 0.0.1
:toc:

WARNING: This work is not affiliated with LinsnLED, nor does it claim to fully describe
the protocol. The purpose of the documentation here is to make the
LinsnLED receivers compatible with other systems than Windows, like Linux,
microcontrollers, …

== Introduction

LED matrix displays are everywhere nowadays. From small 24/7 kiosks that show
that they are open using monochrome LED panels to big advertisement screens in
NY Time Square, London Piccadilly or even high-end cinemas with full color, high
dynamic range images. To support such large installations, the hardware itself
has become relatively cheap. With just 15€ (+ shipping from China) one can get
their own 64x64 (~0.3ct per LED) / 20 x 20 cm LED panel. This remarkable price is
reached by outsourcing the display logic onto an external module, making the
panel itself just some power wiring and an assortment of shift-registers.

Due to their high availability, simple electrical design and low cost of entry
(and tbqh 'cuz they are just very cool), there have been many attempts at
controlling these using a diverse range of hardware. Some notable ones:

:fn-adafruit-arduino: footnote:[https://github.com/adafruit/RGB-matrix-Panel]
:fn-hzeller-rgb: footnote:[https://github.com/hzeller/rpi-rgb-led-matrix]
:fn-adafruit-fpga: footnote:[https://learn.adafruit.com/fpga-rgb-matrix/overview]

[cols="1,2"]
|===

|Adafruit's RGB Matrix Panel lib{fn-adafruit-arduino}
|Controls a HUB75 style RGB matrix using and the GPIO pins of an Arduino. They
also have a newer one, for the newer Arduino models. This is compatible with
the LED matrix they sell

|HZeller's RPi RGB LED Matrix{fn-hzeller-rgb}
|Using the RPi GPIO and some clever tricks with its hardware PWM, they actually
archive driving compatible panels with full rgb and 30fps.

|Adafruit's FPGA LED matrix tutorial{fn-adafruit-fpga}
|An honorable mention, because FPGAs are the way the professionals do it - but more on
that later.
|===

And these are just the projects by big organizations or that are often
recommended. Just searching for the term "LED Matrix" on GitHub.com presents us
with 6.7k results, so the general interest is quite high.

But almost all open source projects do not take full advantage of the
(honestly) dumb piece of PCB they control. Due to the fact, that every driving
logic resides outside the panels, using the right controller can be the
difference between a monochrome RGB display with ~1 FPS refresh rate, or a
12bit HDR 120fps display using the exact same LED panel. So it's only natural,
that professionals do not use their custom controller solution, but instead
employ a proven off the shelf solution. And here comes our company into the
larger picture: LinsnLED.

:fn-q3k-led: footnote:[Using a receiver as a dev platform: https://github.com/q3k/chubby75]

LinsnLED is one of the more well known companies which design, program and
produce controller modules for the aforementioned LED panels. Their so-called
receiver modules (aka receives images and controls LED panels) can be driven
over a simple Ethernet cable and are fairly cheap at around 15€ per piece on
AliExpress. There are many reasons why they are cool. Starting with the fact
that they were one of the cheaper FPGA dev platforms{fn-q3k-led} out there, when
FPGAs weren't really in reach yet for tinkerers around the globe. Over the fact
that a single one can sometimes drive even large installations (720p), expanding
on that ability by simply adding more receivers. To the reason why they have
been chosen for this reverse engineering project: They are highly configurable
and as such compatible with almost every LED panel out there.

Sadly there is no open source driver available so far, but only Linsn's Windows
based application or their controller modules that accept HDMI, DVI or VGA
input. Luckily for us there is not a lot of magic behind it, meaning that even a
single RPi might be able to render to a large LED screen in the future. But to
do this we first need to understand the protocol they use, which is the focus of
this document.

=== Previous Research

The protocol has been explored multiple times in the past, but so far without
great success.

:fn-mikrokontroller: footnote:[https://www.mikrocontroller.net/topic/352894]
:fn-eevblog: footnote:[https://www.eevblog.com/forum/projects/reverse-engineering-a-chinese-led-screen-control-thing-interesting!/50/]
:fn-chubby75-rv908: footnote:[https://github.com/q3k/chubby75/issues/20]

A simple replay "attack" has been done by Frank E. from
mikrokontroller.net{fn-mikrokontroller}, demonstrating the stateless property of
the protocol and the initial feasibility of controlling the Linsn RV908 modules
through a simple Ethernet port.

In an eevblog forum thread{fn-eevblog} some users explored the serial protocol
to control the controller / sender card, which can be connected to a receiver.
Even though this is raw serial, it is relevant in the Ethernet protocol, as can
be seen later on. Sadly the research stopped with many questions still
unanswered.

The hardware of our receiver module was documented by chubby, although there
seem to be multiple revisions of the same module out there. Ours does not have a
separate RAM module on board and uses a different FPGA.{fn-chubby75-rv908}

== The hardware

:fn-chubby75-rv901: footnote:[https://github.com/q3k/chubby75/blob/master/rv901t/README.md]
:fn-chubby75-rv901-hardware: footnote:[https://github.com/q3k/chubby75/blob/master/rv901t/doc/hardware.md]

The research was done using a modern RV908M32 receiver module by LinsnLED. It
has 12 HUB75 outputs, with each being able to control a chain of panels (the
exact amount depends on a few factors). The processing is done by an Analogic FPGA.
Overall a single RV908M32 can control up to 1024 x 256 pixels at 12bit HDR and
variable FPS. The communication happens over a single 1G Ethernet cable. The
board itself is driven over 5V input, but is not responsible for providing power
the panels themselves. They seem to have the ability to measure the power usage
of the panels, but this has not been verified nor tested.

NOTE: After looking into the protocol we are mostly sure, that the
protocol does not change between receiver revisions and as such is fully
backwards compatible. Of course hardware limits of the respective receivers
apply.

=== SPI

An interesting feature of the RV908M32 and RV901{fn-chubby75-rv901} is the
existence of an SPI attached flash on the board. Luckily Linsn has not removed
nor destroyed the SPI programming header which allowed us to read the FPGA
bitstream. The SPI flash can be accessed the following way (from
Chubby75{fn-chubby75-rv901-hardware}).

[quote,Chubby75 RV901 hardware description]
____
The SPI flash holding the configuration memory (U2) is accessible via JP5. The
flash I/Os are unbuffered 3.3V, connected through 33Ω resistors. The PROG_B
signal has to be pulled LOW to GND [without a resistor] in order to access
the SPI flash.
____

.SPI Programming header pinout - adapted from Chubby75{fn-chubby75-rv901-hardware}
[cols="6*^"]
|===
|Shared|SPI Pin|Header Pin|Header Pin|SPI Pin|Shared

|CLK  |CLK  | 1|2 |     |
|MISO |DO   | 3|4 |     |5V
|     |     | 5|6 |     |PROG_B
|CS   |CS   | 7|8 |     |
|MOSI |DI   | 9|10|GND  |GND
|===

Interestingly all non-volatile configuration is also stored here, meaning that
in a large scale system it is plausible to recover and restore the configuration
by using the header. This might be useful in cases, where the board does not
respond anymore due to misconfiguration, so it is recommended to backup up the
data stored there before exploring the hardware.

=== Ethernet

:fn-mae0621b: footnote:[http://www.maxio-tech.com/product/12928/12929/12930/13005.html]

Our board uses a Chinese produced 1000BASE-T Ethernet chip called Maxio
MAE0621B{fn-mae0621b}. Contrary to statements made by Linsn, the chip supports
MDI-X, meaning that no Ethernet crossover cable is required. It is otherwise a
fairly normal 1000BASE-T Ethernet chip, that supports most common features one
would expect.

=== FPGA

:fn-prjtang: footnote:[https://github.com/mmicko/prjtang/blob/master/docs/architecture/bitstream_format.rst]

As mentioned before we were able to read the FPGA bitstream from the flash.
Without going into much detail here, we found that our revision of the RV908M32
uses an Anlogic EG4S20BG256. This is in contrast to the Xilinx based FPGA they
used as late as 2020. We figured this out, by using the bitstream format
description for Anlogic FPGAs by the mmicko/prjtang project{fn-prjtang}. With
this change Linsn was able to remove the external DRAM from the board, as the
Anlogic FPGAs have one already integrated, presumably reducing the manufacturing
cost.

It is known through the Chubby75 project{fn-chubby75-rv908}, that it can be
accessed using exposed JTAG contacts. There has been no further research into
the FPGA itself as this is not the focus of this project.

=== The LED panel

:fn-tang-nano: footnote:[WayBack because they broke their images: https://web.archive.org/web/20240422085913/https://learn.lushaylabs.com/led-panel-hub75/]

The LED panels we used here are standard HUB75 RGB LED panels. There have been
numerous description on their inner workings before. See for example C. Klüser's
extensive post on Lushay Labs using a Tang Nano FPGA{fn-tang-nano} to control
these panels. For this project we used a few very different panels lying around
to explore the receiver and had great success with all of them.

